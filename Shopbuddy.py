# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J2kDdCpiCmGySyy1e1PYarNePcWyYEuG
"""

pip install streamlit google-genai

import streamlit as st
import os
from google import genai
from google.genai.types import GenerateContentConfig, Tool, GoogleSearch
from google.genai.errors import APIError

# ===========================
# 1. SETUP & CONFIGURATION
# ===========================

st.set_page_config(page_title="Smart Shopper (Direct)", page_icon="üõçÔ∏è", layout="wide")

# --- SECRETS MANAGEMENT ---
# The Google SDK expects the API key in os.environ["GEMINI_API_KEY"].
# For Streamlit Cloud deployments, st.secrets can be used. For Colab or local runs,
# we prioritize direct environment variables or user input via the sidebar.

# Fallback: If API key not in os.environ, ask user in sidebar
if "GEMINI_API_KEY" not in os.environ:
    with st.sidebar:
        st.header("üîë Configuration")
        api_key_input = st.text_input("Gemini API Key", type="password")
        if api_key_input:
            os.environ["GEMINI_API_KEY"] = api_key_input
        else:
            st.warning("‚ö†Ô∏è API Key needed to run.")
            st.stop()

# Initialize Client
try:
    client = genai.Client()
except Exception as e:
    st.error(f"Client Init Error: {e}")
    st.stop()

MODEL_ID = "gemini-3-pro-preview"

# ===========================
# 2. SYSTEM INSTRUCTIONS (Personas)
# ===========================

RESEARCHER_INSTRUCTION = """
ROLE: You are a cynical Lead Market Researcher. You only trust verified data.
GOAL: Find real-time pricing, specs, and authentic user reviews.

CORE RULES:
1. VERIFICATION: You NEVER hallucinate prices.
2. SKEPTICISM: If sources conflict, you must check at least 7 distinct source types.
3. TWO-PHASE SEARCH:
   - Phase 1: Broad search for availability.
   - Phase 2: If status is unclear, search specifically for "official price" or "release date".

OUTPUT REQUIREMENT:
Provide a DETAILED, RAW factual dump. Do not summarize yet.
- List specific prices from specific retailers.
- List raw specs found.
- List specific user complaints from forums.
- Explicitly state if the product is RELEASED or RUMORED.
"""

EDITOR_INSTRUCTION = """
ROLE: You are a Senior Tech Editor and Data Analyst.
GOAL: Transform raw research data into a polished, objective Buying Guide.

INPUT DATA: You will receive raw research text. You must trust this text as your ground truth.

PROCESS:
1. ANALYZE: Identify "Consensus" facts vs "Single-Source" claims.
2. FILTER: Remove marketing fluff. Keep only quantifiable data.
3. VISUALIZE:  - Always trigger this tag at the start.

FORMATTING RULES (STRICT):
- Use clean Markdown.
- Use emojis sparingly (üëç, ‚ùå, üí∞).
- NO introductory filler. Start directly with the title.

MANDATORY STRUCTURE:
# {product_name} ‚Äî Buying Guide


## üì± Product Overview
(2 sentence summary based on data)

## ‚≠ê Consensus Pros
- (List items confirmed by multiple sources)

## ‚ùå Consensus Cons
- (List items confirmed by multiple sources)

## ‚öñÔ∏è Notable Disagreements
- (List conflicting specs or mixed review points)

## üí∞ Pricing Summary
| Retailer/Source | Price | Status |
|-----------------|-------|--------|
| (Fill Rows)     | ...   | ...    |
*(Add a data-based comment on value)*

## üõí Final Recommendation
(Who is this for? Should they buy it? derive strictly from data.)
"""

# ===========================
# 3. UI & LOGIC
# ===========================

st.title("üõçÔ∏è Smart Shopper: Agentic AI")
st.caption(f"Powered by **{MODEL_ID}** with Native Google Search Grounding")

product_name = st.text_input("What product are you researching?", placeholder="e.g. Sony A7IV Camera, iPhone 16 Pro")

if st.button("üöÄ Run Research & Analysis", type="primary"):
    if not product_name:
        st.warning("Please enter a product name.")
    else:
        status_container = st.status("Initializing Agents...", expanded=True)

        try:
            # --- STEP 1: RESEARCH (The Hunter) ---
            status_container.write("üïµÔ∏è **Step 1: The Hunter is scouring the web...**")

            research_config = GenerateContentConfig(
                tools=[Tool(google_search=GoogleSearch())],
                system_instruction=RESEARCHER_INSTRUCTION,
                temperature=0.3
            )

            research_response = client.models.generate_content(
                model=MODEL_ID,
                contents=f"Conduct a deep verification search for: {product_name}. Find current prices, specs, and user sentiment.",
                config=research_config
            )

            raw_research_data = research_response.text

            # Show the "Thought Process" / Sources
            with st.expander("View Raw Research Data & Sources"):
                st.markdown(raw_research_data)
                if research_response.candidates[0].grounding_metadata.grounding_chunks:
                    st.caption("Sources Accessed:")
                    for chunk in research_response.candidates[0].grounding_metadata.grounding_chunks:
                         if chunk.web and chunk.web.uri:
                            st.write(f"- {chunk.web.title}: {chunk.web.uri}")

            # --- STEP 2: ANALYSIS & WRITING (The Editor) ---
            status_container.write("‚úçÔ∏è **Step 2: The Editor is compiling the guide...**")

            editor_config = GenerateContentConfig(
                system_instruction=EDITOR_INSTRUCTION.format(product_name=product_name),
                temperature=0.1
            )

            final_prompt = f"""
            Here is the raw research data you collected:
            {raw_research_data}
            Based ONLY on this data, generate the Buying Guide.
            """

            final_response = client.models.generate_content(
                model=MODEL_ID,
                contents=final_prompt,
                config=editor_config
            )

            status_container.update(label="‚úÖ Guide Generated!", state="complete", expanded=False)

            st.divider()
            st.markdown(final_response.text)

        except Exception as e:
            status_container.update(label="‚ùå Error Occurred", state="error")
            st.error(f"An error occurred: {e}")